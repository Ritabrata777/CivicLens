import { ethers } from 'ethers';
// Import the artifact generated by our deployment script
import CivitasArtifact from '@/artifacts/contracts/Civitas.sol/Civitas.json';

// Use the address from the artifact if available, or fallback to env var logic if needed.
// For local Ganache, the artifact address is the most up-to-date source.
export const CONTRACT_ADDRESS = (CivitasArtifact as any).address;

export const getEthereumObject = () => {
    if (typeof window !== 'undefined' && (window as any).ethereum) {
        return (window as any).ethereum;
    }
    return null;
};

export const isWalletConnected = async () => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) return null;

        const accounts = await ethereum.request({ method: "eth_accounts" });
        if (accounts.length > 0) {
            return accounts[0];
        } else {
            return null;
        }
    } catch (error) {
        console.error("Error checking if wallet is connected:", error);
        return null;
    }
};

export const connectWallet = async () => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) {
            alert("Make sure you have MetaMask!");
            return null;
        }

        const accounts = await ethereum.request({ method: "eth_requestAccounts" });
        return accounts[0];
    } catch (error: any) {
        console.error("Error connecting wallet:", error?.message || error);
        return null;
    }
};

export const verifyIssueOnChain = async (issueId: string, adminId: string, status: string) => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) {
            throw new Error("Ethereum object not found");
        }

        const provider = new ethers.BrowserProvider(ethereum);
        const signer = await provider.getSigner();
        // contract address and abi must be correct
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, signer);

        const tx = await contract.verifyIssue(issueId, adminId, status);
        console.log("Transaction sent:", tx.hash);
        await tx.wait();
        console.log("Transaction confirmed:", tx.hash);

        return tx.hash;

    } catch (error) {
        console.error("Error verifying issue on chain:", error);
        throw error;
    }
};

export const parseAdminWallets = (): string[] => {
    const wallets = process.env.NEXT_PUBLIC_ADMIN_WALLETS || "";
    return wallets.split(',').map(w => w.trim().toLowerCase());
};

export const checkIsAdminEnv = (address: string): boolean => {
    const admins = parseAdminWallets();
    return admins.includes(address.toLowerCase());
};

export const getAdminName = async (address: string): Promise<string> => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) return "";
        const provider = new ethers.BrowserProvider(ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, provider);
        return await contract.adminNames(address);
    } catch (error) {
        console.error("Error fetching admin name:", error);
        return "";
    }
};

export const setAdminName = async (name: string): Promise<string> => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) throw new Error("No ethereum object");
        const provider = new ethers.BrowserProvider(ethereum);
        const signer = await provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, signer);

        const tx = await contract.setAdminName(name);
        await tx.wait();
        return tx.hash;
    } catch (error) {
        console.error("Error setting admin name:", error);
        throw error;
    }
};

// ... existing imports

export const getIssueDetails = async (issueId: string) => {
    try {
        if (!CONTRACT_ADDRESS) {
            console.warn("Contract address is missing. Skipping blockchain verification.");
            return null;
        }

        const ethereum = getEthereumObject();
        // If no wallet (public user), we can try to use a default provider (e.g. Infura/Alchemy) if configured,
        // but for now we'll rely on the user having a wallet OR gracefully handle the "no provider" case 
        // by returning null (which hides the verified card).
        // Ideally, we'd use a JsonRpcProvider for public/read-only access without a wallet.
        if (!ethereum) return null;

        const provider = new ethers.BrowserProvider(ethereum);
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, provider);

        // The 'issues' mapping returns (issueId, adminId, timestamp, status, exists)
        const result = await contract.issues(issueId);

        // Check 'exists' boolean (index 4 in the struct/array)
        if (!result || !result[4]) {
            return null;
        }

        return {
            issueId: result[0],
            adminId: result[1],
            timestamp: Number(result[2]), // Convert BigInt to number
            status: result[3],
            exists: result[4],
            // We can't easily get the txHash from a mapping read unless we stored it or query events.
            // For now, we'll link to the explorer using the contract address or just show "Verified".
        };
    } catch (error) {
        console.error("Error fetching issue details:", error);
        return null;
    }
};

export const distributeReward = async (to: string, amount: number): Promise<string> => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) throw new Error("No ethereum object");
        const provider = new ethers.BrowserProvider(ethereum);
        const signer = await provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, signer);

        const tx = await contract.distributeReward(to, amount);
        await tx.wait();
        return tx.hash;
    } catch (error) {
        console.error("Error distributing rewards:", error);
        throw error;
    }
};
