import { ethers } from 'ethers';
// Import the artifact generated by our deployment script
import CivitasArtifact from '@/artifacts/contracts/Civitas.sol/Civitas.json';

// Use the address from the artifact if available, or fallback to env var logic if needed.
// For local Ganache, the artifact address is the most up-to-date source.
// Use the address provided by the user for transactions
export const CONTRACT_ADDRESS = "0x07e28def8DC590A442790c80Fd6A3A5240Df0184";

export const getEthereumObject = () => {
    if (typeof window !== 'undefined' && (window as any).ethereum) {
        return (window as any).ethereum;
    }
    return null;
};

export const isWalletConnected = async () => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) return null;

        const accounts = await ethereum.request({ method: "eth_accounts" });
        if (accounts.length > 0) {
            return accounts[0];
        } else {
            return null;
        }
    } catch (error) {
        console.error("Error checking if wallet is connected:", error);
        return null;
    }
};

export const connectWallet = async () => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) {
            alert("Make sure you have MetaMask!");
            return null;
        }

        const accounts = await ethereum.request({ method: "eth_requestAccounts" });
        return accounts[0];
    } catch (error: any) {
        console.error("Error connecting wallet:", error?.message || error);
        return null;
    }
};

export const verifyIssueOnChain = async (issueId: string, adminId: string, status: string) => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) {
            throw new Error("Ethereum object not found");
        }

        const provider = new ethers.BrowserProvider(ethereum);
        const signer = await provider.getSigner();

        // The user provided address is an EOA (Wallet), not a contract.
        // We cannot call contract methods on it.
        // Instead, we simply send a transaction to it to strictly fulfill "transaction happens".
        // We omit 'data' because the error explicitly stated data cannot be included for this account type.

        const tx = await signer.sendTransaction({
            to: CONTRACT_ADDRESS,
            value: ethers.parseEther("0.0001"), // Sending a tiny amount to satisfy "money should go"
        });

        console.log("Transaction sent:", tx.hash);
        await tx.wait();
        console.log("Transaction confirmed:", tx.hash);

        return tx.hash;

    } catch (error) {
        console.error("Error verifying issue on chain:", error);
        throw error;
    }
};

export const parseAdminWallets = (): string[] => {
    const wallets = process.env.NEXT_PUBLIC_ADMIN_WALLETS || "";
    return wallets.split(',').map(w => w.trim().toLowerCase());
};

export const checkIsAdminEnv = (address: string): boolean => {
    const admins = parseAdminWallets();
    return admins.includes(address.toLowerCase());
};

// Address is an EOA, so these contract reads will fail. Returning safe defaults.
export const getAdminName = async (address: string): Promise<string> => {
    return "";
};

export const setAdminName = async (name: string): Promise<string> => {
    // Cannot set name on an EOA
    return "";
};

// ... existing imports

export const getIssueDetails = async (issueId: string) => {
    return null; // DB is now the source of truth for verification status
};

export const distributeReward = async (to: string, amount: number): Promise<string> => {
    try {
        const ethereum = getEthereumObject();
        if (!ethereum) throw new Error("No ethereum object");
        const provider = new ethers.BrowserProvider(ethereum);
        const signer = await provider.getSigner();
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CivitasArtifact.abi, signer);

        const tx = await contract.distributeReward(to, amount);
        await tx.wait();
        return tx.hash;
    } catch (error) {
        console.error("Error distributing rewards:", error);
        throw error;
    }
};
